#!/bin/bash
#
# Enterprise Network Deployment with 802.1x and SCEP
# Version: 2.4.4 - Deprioritize Old WiFi (Safer)
# 
# Features:
# - SILENT: Only final result to stdout, all logs to file
# - SAFE: Deprioritizes old WiFi instead of deleting (backup)
# - Auto-installs NetworkManager if missing
# - Handles systemd-networkd/netplan conflicts
# - NO DISRUPTION: Preserves active connections
# - Deprioritizes old *indra* WiFi profiles (priority 1 - backup)
# - Creates IndraNavia (802.1x, guest VLAN fallback)
# - Auto-detects hidden vs visible SSID
# - Idempotent: Safe to run multiple times
# - NO KERBEROS: Works on non-domain-joined machines
# - Cleans up old certificate requests
# - Ensures ethernet interfaces are managed
# - Auto-fixes /etc/network/interfaces conflicts (Debian/Ubuntu)
# - Pre-flight checks before deployment
# - Post-deployment verification
# - Automatic rollback on critical failures
#
# Exit Codes:
# - 0 = SUCCESS
# - 1 = FAILED
#

set -e
set -o pipefail

# ============================================
# Configuration
# ============================================

# SCEP Configuration
SCEP_URL="https://ndesscep-indranavia.msappproxy.net/certsrv/mscep/mscep.dll"
CA_NAME="NDES"
DOMAIN_SUFFIX="ad.indra.no"

# Certificate paths
CERT_BASE_PATH="/etc/pki/802.1x"
MACHINE_CERT="${CERT_BASE_PATH}/machine.crt"
MACHINE_KEY="${CERT_BASE_PATH}/machine.key"
CA_CERT="${CERT_BASE_PATH}/ca-chain.pem"

# Network Configuration
WIRED_CONNECTION_NAME="Wired-802.1x"
WIRED_PRIORITY=100

# WiFi: 802.1x (NO PASSWORD - guest VLAN fallback if no cert)
WIFI_CONNECTION_NAME="IndraNavia"
WIFI_SSID="IndraNavia"
WIFI_PRIORITY=50

# 802.1x Configuration
EAP_METHOD="tls"  # Certificate-based

# Fallback priority for existing connections
EXISTING_FALLBACK_PRIORITY=5

# Old Indra WiFi profiles priority (backup)
OLD_INDRA_PRIORITY=1

# Logging
LOG_FILE="/var/log/enterprise-network-deployment.log"

# Rollback state file
STATE_FILE="/tmp/enterprise-deployment-state.$$"

# ============================================
# Logging Functions - SILENT MODE
# ============================================
# All logs go to file only, not stdout
# ManageEngine will see only final result

log() {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

log_error() {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $1" >> "$LOG_FILE"
}

log_section() {
  echo "" >> "$LOG_FILE"
  echo "==========================================" >> "$LOG_FILE"
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
  echo "==========================================" >> "$LOG_FILE"
}

log_warn() {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] WARN: $1" >> "$LOG_FILE"
}

log_success() {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] ✓ $1" >> "$LOG_FILE"
}

log_debug() {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] DEBUG: $1" >> "$LOG_FILE"
}

# ============================================
# Rollback Functions
# ============================================

record_state() {
  echo "$1" >> "$STATE_FILE"
}

rollback() {
  if [ ! -f "$STATE_FILE" ]; then
    return
  fi
  
  log_error "Deployment failed - initiating rollback..."
  
  while IFS= read -r action; do
    case "$action" in
      CERT_REQUESTED:*)
        REQ_ID="${action#CERT_REQUESTED:}"
        log "Rolling back certificate request: $REQ_ID"
        getcert stop-tracking -i "$REQ_ID" 2>/dev/null || true
        ;;
      CONNECTION_CREATED:*)
        CONN_NAME="${action#CONNECTION_CREATED:}"
        log "Rolling back connection: $CONN_NAME"
        nmcli connection delete "$CONN_NAME" 2>/dev/null || true
        ;;
      FILE_MODIFIED:*)
        FILE_PATH="${action#FILE_MODIFIED:}"
        if [ -f "${FILE_PATH}.backup-rollback" ]; then
          log "Restoring file: $FILE_PATH"
          mv "${FILE_PATH}.backup-rollback" "$FILE_PATH"
        fi
        ;;
    esac
  done < "$STATE_FILE"
  
  rm -f "$STATE_FILE"
  log_error "Rollback complete. Check logs at $LOG_FILE"
}

cleanup_on_exit() {
  EXIT_CODE=$?
  
  if [ $EXIT_CODE -ne 0 ]; then
    log_error "Script exited with code: $EXIT_CODE"
    rollback
    
    # Output to stdout for ManageEngine
    echo "FAILED: Deployment failed on $(hostname). Check log: $LOG_FILE" >&2
  else
    # Clean up state file on success
    rm -f "$STATE_FILE"
  fi
}

trap cleanup_on_exit EXIT

# ============================================
# Pre-flight Checks
# ============================================

preflight_checks() {
  log_section "Pre-flight Checks"
  
  local CHECKS_PASSED=true
  
  # 1. Check SCEP URL connectivity
  log "Testing SCEP URL connectivity..."
  if curl -k -I --connect-timeout 10 --max-time 15 "$SCEP_URL" &>/dev/null; then
    log_success "SCEP URL reachable: $SCEP_URL"
  else
    log_error "Cannot reach SCEP URL: $SCEP_URL"
    log_error "Check network connectivity and firewall rules"
    CHECKS_PASSED=false
  fi
  
  # 2. Check disk space (need at least 10MB)
  log "Checking disk space..."
  AVAILABLE_KB=$(df /etc/pki 2>/dev/null | awk 'NR==2 {print $4}' || echo "0")
  if [ "$AVAILABLE_KB" -gt 10240 ]; then
    log_success "Sufficient disk space: ${AVAILABLE_KB}KB available"
  else
    log_error "Insufficient disk space: ${AVAILABLE_KB}KB (need 10MB+)"
    CHECKS_PASSED=false
  fi
  
  # 3. Check DNS resolution for NDES
  log "Testing DNS resolution..."
  NDES_HOST=$(echo "$SCEP_URL" | sed 's|https://||;s|/.*||')
  if host "$NDES_HOST" &>/dev/null; then
    log_success "DNS resolution works for: $NDES_HOST"
  else
    log_warn "DNS resolution failed for: $NDES_HOST"
    log_warn "This may be temporary or expected (Azure App Proxy)"
  fi
  
  # 4. Check if certmonger will be available
  log "Checking certmonger availability..."
  if command -v getcert &>/dev/null || [ -f /usr/bin/getcert ] || [ -f /usr/sbin/getcert ]; then
    log_success "Certmonger available"
  else
    log "Certmonger not installed (will be installed)"
  fi
  
  # 5. Check if running as root
  if [ "$EUID" -eq 0 ]; then
    log_success "Running as root"
  else
    log_error "Must run as root"
    CHECKS_PASSED=false
  fi
  
  # 6. Check NetworkManager availability or installability
  if command -v nmcli &>/dev/null; then
    log_success "NetworkManager available"
  else
    log "NetworkManager not installed (will be installed)"
  fi
  
  log ""
  if [ "$CHECKS_PASSED" = false ]; then
    log_error "Pre-flight checks FAILED"
    log_error "Fix the issues above before proceeding"
    exit 1
  else
    log_success "All pre-flight checks PASSED"
  fi
}

# ============================================
# Post-deployment Verification
# ============================================

verify_deployment() {
  log_section "Post-Deployment Verification"
  
  local VERIFY_PASSED=true
  
  # 1. Verify certificate exists and is valid
  log "Verifying certificate..."
  if [ -f "$MACHINE_CERT" ] && [ -f "$MACHINE_KEY" ]; then
    if openssl x509 -in "$MACHINE_CERT" -noout -checkend 86400 &>/dev/null; then
      log_success "Certificate valid and not expiring within 24h"
    else
      log_error "Certificate invalid or expiring soon"
      VERIFY_PASSED=false
    fi
  else
    log_error "Certificate files missing"
    VERIFY_PASSED=false
  fi
  
  # 2. Verify certificate chain
  if [ -f "$CA_CERT" ] && [ -f "$MACHINE_CERT" ]; then
    log "Verifying certificate chain..."
    if openssl verify -CAfile "$CA_CERT" "$MACHINE_CERT" &>/dev/null; then
      log_success "Certificate chain valid"
    else
      log_warn "Certificate chain verification failed (may be OK if intermediate CA)"
    fi
  fi
  
  # 3. Verify certmonger tracking
  log "Verifying certmonger tracking..."
  REQUEST_ID="enterprise-8021x-${HOSTNAME}"
  if getcert list -i "$REQUEST_ID" 2>/dev/null | grep -q "status: MONITORING"; then
    log_success "Certmonger tracking active: $REQUEST_ID"
  else
    log_error "Certmonger not tracking certificate"
    VERIFY_PASSED=false
  fi
  
  # 4. Verify NetworkManager connections exist
  log "Verifying NetworkManager connections..."
  if nmcli connection show "$WIRED_CONNECTION_NAME" &>/dev/null 2>&1; then
    log_success "Wired 802.1x connection exists"
  else
    log_warn "Wired 802.1x connection not created (may be WiFi-only machine)"
  fi
  
  # 5. Verify ethernet interfaces are managed (if present)
  WIRED_INTERFACES=$(nmcli -t -f DEVICE,TYPE device 2>/dev/null | grep ethernet | cut -d: -f1 || true)
  if [ -n "$WIRED_INTERFACES" ]; then
    log "Verifying ethernet interfaces are managed..."
    UNMANAGED_COUNT=0
    for IF in $WIRED_INTERFACES; do
      IF_STATE=$(nmcli -t -f DEVICE,STATE device status 2>/dev/null | grep "^${IF}:" | cut -d: -f2 || echo "unknown")
      if [[ "$IF_STATE" == "unmanaged" || "$IF_STATE" == "uhåndteret" ]]; then
        UNMANAGED_COUNT=$((UNMANAGED_COUNT + 1))
      fi
    done
    
    if [ $UNMANAGED_COUNT -eq 0 ]; then
      log_success "All ethernet interfaces managed"
    else
      log_warn "$UNMANAGED_COUNT ethernet interface(s) still unmanaged (reboot may fix)"
    fi
  fi
  
  # 6. Basic network connectivity test
  log "Testing network connectivity..."
  if ping -c 1 -W 2 8.8.8.8 &>/dev/null; then
    log_success "Network connectivity OK"
  else
    log_warn "No network connectivity (may be expected if offline)"
  fi
  
  log ""
  if [ "$VERIFY_PASSED" = false ]; then
    log_error "Deployment verification FAILED"
    log_error "Check the errors above"
    return 1
  else
    log_success "All deployment verifications PASSED"
    return 0
  fi
}

# ============================================
# Pre-flight Checks and Auto-install
# ============================================

log_section "Enterprise Network Deployment Starting"
log "Version: 2.4.4 - Deprioritize Old WiFi (Safer)"

touch "$LOG_FILE"
chmod 600 "$LOG_FILE"

# Run pre-flight checks first
preflight_checks

# Hostname
HOSTNAME=$(hostname -s)
FQDN="${HOSTNAME}.${DOMAIN_SUFFIX}"
log "Hostname: $HOSTNAME"
log "FQDN: $FQDN"

# Detect OS first (needed for package installation)
if [ -f /etc/os-release ]; then
  . /etc/os-release
  OS=$ID
  log "OS: $NAME $VERSION_ID"
else
  log_error "Cannot detect OS"
  exit 1
fi

# ============================================
# Auto-install NetworkManager if missing
# ============================================

if ! command -v nmcli &>/dev/null; then
  log "NetworkManager not found - installing..."
  
  case "$OS" in
    fedora)
      log "Installing NetworkManager on Fedora..."
      dnf install -y NetworkManager NetworkManager-wifi &>/dev/null
      ;;
    debian|ubuntu)
      log "Installing NetworkManager on Debian/Ubuntu..."
      export DEBIAN_FRONTEND=noninteractive
      apt-get update -qq
      apt-get install -y network-manager &>/dev/null
      ;;
    *)
      log_error "Unsupported OS: $OS"
      exit 1
      ;;
  esac
  
  log_success "NetworkManager installed"
fi

# ============================================
# Handle network management conflicts
# ============================================

log "Checking for network management conflicts..."

# Stop systemd-networkd if running
if systemctl is-active --quiet systemd-networkd; then
  log_warn "systemd-networkd is active - disabling in favor of NetworkManager"
  systemctl stop systemd-networkd &>/dev/null
  systemctl disable systemd-networkd &>/dev/null
  log_success "systemd-networkd disabled"
fi

# Handle netplan (Ubuntu/Debian)
if [ -d /etc/netplan ] && [ "$(ls -A /etc/netplan/*.yaml 2>/dev/null)" ]; then
  log_warn "Netplan configuration detected - switching to NetworkManager"
  
  # Backup netplan
  BACKUP_DIR="/etc/netplan.backup-$(date +%Y%m%d-%H%M%S)"
  mkdir -p "$BACKUP_DIR"
  cp /etc/netplan/*.yaml "$BACKUP_DIR/" 2>/dev/null || true
  log "Netplan backed up to: $BACKUP_DIR"
  
  # Create NetworkManager renderer
  cat > /etc/netplan/01-network-manager-all.yaml <<'EOF'
# Managed by enterprise-network-deployment script
network:
  version: 2
  renderer: NetworkManager
EOF
  
  record_state "FILE_MODIFIED:/etc/netplan/01-network-manager-all.yaml"
  
  # Apply
  if command -v netplan &>/dev/null; then
    netplan apply &>/dev/null || true
  fi
  
  log_success "Netplan configured for NetworkManager"
fi

# ============================================
# Start NetworkManager
# ============================================

if ! systemctl is-active --quiet NetworkManager; then
  log "Starting NetworkManager..."
  
  systemctl enable NetworkManager &>/dev/null
  systemctl start NetworkManager
  
  # Wait for NetworkManager to initialize
  TIMEOUT=30
  ELAPSED=0
  while [ $ELAPSED -lt $TIMEOUT ]; do
    if systemctl is-active --quiet NetworkManager; then
      log_success "NetworkManager started"
      sleep 5  # Wait for full initialization
      break
    fi
    sleep 1
    ELAPSED=$((ELAPSED + 1))
  done
  
  if ! systemctl is-active --quiet NetworkManager; then
    log_error "NetworkManager failed to start"
    systemctl status NetworkManager >> "$LOG_FILE" 2>&1
    exit 1
  fi
else
  log "NetworkManager: already running"
fi

# Final verification
if ! command -v nmcli &>/dev/null; then
  log_error "nmcli still not available after installation"
  exit 1
fi

# Test nmcli
if ! nmcli general status &>/dev/null; then
  log_error "nmcli not responding"
  exit 1
fi

log_success "NetworkManager ready"

# ============================================
# [1/9] Detect Current Network Status
# ============================================

log_section "[1/9] Detecting Current Network Status (SAFE MODE)"

# Get all active connections (with error handling)
ACTIVE_CONNECTIONS=$(nmcli -t -f NAME,TYPE,DEVICE connection show --active 2>/dev/null || true)

if [ -n "$ACTIVE_CONNECTIONS" ]; then
  log "Currently active connections:"
  echo "$ACTIVE_CONNECTIONS" | while IFS=: read -r name type device; do
    log "  - $name ($type on $device)"
  done
else
  log "No active connections (machine may be offline)"
fi

# Track what's currently active
ACTIVE_WIRED_CONNECTION=""
ACTIVE_WIRED_DEVICE=""
ACTIVE_WIFI_CONNECTION=""
ACTIVE_WIFI_DEVICE=""

# Find active wired connection (with error handling)
log_debug "Searching for active wired connections..."
ACTIVE_WIRED=$(echo "$ACTIVE_CONNECTIONS" | grep ":ethernet:" | head -1 || true)
if [ -n "$ACTIVE_WIRED" ]; then
  ACTIVE_WIRED_CONNECTION=$(echo "$ACTIVE_WIRED" | cut -d: -f1)
  ACTIVE_WIRED_DEVICE=$(echo "$ACTIVE_WIRED" | cut -d: -f3)
  log "Active wired: $ACTIVE_WIRED_CONNECTION on $ACTIVE_WIRED_DEVICE"
else
  log_debug "No active wired connections found"
fi

# Find active WiFi connection (with error handling)
log_debug "Searching for active WiFi connections..."
ACTIVE_WIFI=$(echo "$ACTIVE_CONNECTIONS" | grep ":wifi:" | head -1 || true)
if [ -n "$ACTIVE_WIFI" ]; then
  ACTIVE_WIFI_CONNECTION=$(echo "$ACTIVE_WIFI" | cut -d: -f1)
  ACTIVE_WIFI_DEVICE=$(echo "$ACTIVE_WIFI" | cut -d: -f3)
  log "Active WiFi: $ACTIVE_WIFI_CONNECTION on $ACTIVE_WIFI_DEVICE"
else
  log_debug "No active WiFi connections found"
fi

# ============================================
# [2/9] Install Required Packages
# ============================================

log_section "[2/9] Installing Required Packages"

case "$OS" in
  fedora)
    dnf install -y certmonger NetworkManager wpa_supplicant openssl curl &>/dev/null
    dnf install -y NetworkManager-wifi &>/dev/null || log "WiFi support not available"
    ;;
  debian|ubuntu)
    export DEBIAN_FRONTEND=noninteractive
    apt-get update -qq
    apt-get install -y certmonger network-manager wpasupplicant openssl curl &>/dev/null
    ;;
  *)
    log_error "Unsupported OS: $OS"
    exit 1
    ;;
esac

systemctl enable --now certmonger &>/dev/null
log_success "Packages installed"

# ============================================
# [3/9] SCEP Certificate Enrollment
# ============================================

log_section "[3/9] SCEP Certificate Enrollment"

mkdir -p "$CERT_BASE_PATH"
chmod 700 "$CERT_BASE_PATH"

# Configure SCEP CA
if ! getcert list-cas | grep -q "^CA '$CA_NAME'"; then
  log "Configuring SCEP CA..."
  getcert add-scep-ca -c "$CA_NAME" -u "$SCEP_URL"
  log_success "SCEP CA configured"
else
  log "SCEP CA already configured"
fi

# ============================================
# Clean up old Indra certificate requests
# ============================================

log "Checking for old certificate requests..."

# Get all request IDs for this hostname and CA
ALL_REQUESTS=$(getcert list 2>/dev/null | grep "Request ID" | awk '{print $3}' | tr -d "'" || true)

if [ -n "$ALL_REQUESTS" ]; then
  CLEANED_COUNT=0
  
  while IFS= read -r REQ_ID; do
    # Skip empty lines
    [ -z "$REQ_ID" ] && continue
    
    # Get details for this request
    REQ_CA=$(getcert list -i "$REQ_ID" 2>/dev/null | grep "^[[:space:]]*CA:" | awk '{print $2}' || true)
    REQ_SUBJECT=$(getcert list -i "$REQ_ID" 2>/dev/null | grep "^[[:space:]]*subject:" | cut -d: -f2- || true)
    
    # Check if it's an Indra cert for this hostname
    if [[ "$REQ_CA" == "$CA_NAME" ]] && [[ "$REQ_SUBJECT" == *"$HOSTNAME"* || "$REQ_SUBJECT" == *"$FQDN"* ]]; then
      
      # Skip our canonical request ID
      if [[ "$REQ_ID" == "enterprise-8021x-${HOSTNAME}" ]]; then
        log "  Keeping: $REQ_ID (canonical 802.1x certificate)"
        continue
      fi
      
      # Remove old/duplicate request
      log_warn "  Removing old certificate request: $REQ_ID"
      getcert stop-tracking -i "$REQ_ID" 2>/dev/null || true
      CLEANED_COUNT=$((CLEANED_COUNT + 1))
    fi
  done <<< "$ALL_REQUESTS"
  
  if [ $CLEANED_COUNT -gt 0 ]; then
    log_success "Cleaned up $CLEANED_COUNT old certificate request(s)"
  else
    log_success "No old certificate requests to clean"
  fi
fi

# Check existing canonical certificate
REQUEST_ID="enterprise-8021x-${HOSTNAME}"
CERT_ENROLLED=false

if getcert list -i "$REQUEST_ID" 2>/dev/null | grep -q "status: MONITORING"; then
  if [ -f "$MACHINE_CERT" ] && [ -f "$MACHINE_KEY" ]; then
    log "Certificate already enrolled and valid"
    CERT_ENROLLED=true
  else
    log "Certificate tracking exists but files missing"
    getcert stop-tracking -i "$REQUEST_ID" 2>/dev/null || true
  fi
fi

if [ "$CERT_ENROLLED" = false ]; then
  getcert stop-tracking -i "$REQUEST_ID" 2>/dev/null || true
  rm -f "$MACHINE_CERT" "$MACHINE_KEY"
  
  log "Requesting certificate for: $FQDN"
  log "Note: Machine is NOT domain-joined (hostname-based enrollment)"
  
  # Request certificate WITHOUT Kerberos principal (-K flag removed)
  # Only CN and DNS SAN
  getcert request \
    -c "$CA_NAME" \
    -I "$REQUEST_ID" \
    -k "$MACHINE_KEY" \
    -f "$MACHINE_CERT" \
    -N "CN=$FQDN" \
    -D "$FQDN" \
    -r
  
  record_state "CERT_REQUESTED:$REQUEST_ID"
  
  log "Waiting for certificate (max 120 sec)..."
  
  TIMEOUT=120
  ELAPSED=0
  
  while [ $ELAPSED -lt $TIMEOUT ]; do
    sleep 2
    ELAPSED=$((ELAPSED + 2))
    
    STATUS=$(getcert list -i "$REQUEST_ID" 2>/dev/null | grep "status:" | awk '{print $2}')
    
    case "$STATUS" in
      MONITORING)
        log_success "Certificate enrolled successfully!"
        break
        ;;
      CA_REJECTED)
        log_error "Certificate REJECTED by NDES"
        log_error ""
        log_error "Detailed error:"
        getcert list -i "$REQUEST_ID" >> "$LOG_FILE" 2>&1
        log_error ""
        log_error "Common causes:"
        log_error "  1. NDES policy requires domain-joined machines"
        log_error "  2. Hostname format not allowed"
        log_error "  3. NDES enrollment permissions not configured"
        log_error "  4. Certificate template restrictions"
        log_error ""
        log_error "To debug:"
        log_error "  - Check NDES logs on CA server"
        log_error "  - Verify NDES enrollment permissions"
        log_error "  - Test SCEP URL: curl -k -I $SCEP_URL"
        exit 1
        ;;
      CA_UNREACHABLE)
        log_error "CA UNREACHABLE"
        log_error ""
        log_error "Detailed error:"
        getcert list -i "$REQUEST_ID" >> "$LOG_FILE" 2>&1
        log_error ""
        log_error "Check network connectivity:"
        log_error "  curl -k -I $SCEP_URL"
        exit 1
        ;;
      NEED_GUIDANCE|SUBMITTING)
        # Still processing
        ;;
      *)
        if [ $((ELAPSED % 10)) -eq 0 ]; then
          log "Current status: $STATUS (waiting...)"
        fi
        ;;
    esac
  done
  
  if [ "$STATUS" != "MONITORING" ]; then
    log_error "Certificate enrollment timeout"
    log_error "Final status: $STATUS"
    log_error ""
    log_error "Full request details:"
    getcert list -i "$REQUEST_ID" >> "$LOG_FILE" 2>&1
    exit 1
  fi
fi

chmod 644 "$MACHINE_CERT"
chmod 600 "$MACHINE_KEY"

log "Certificate: $MACHINE_CERT"
log "Private Key: $MACHINE_KEY"

# Verify certificate details
log "Certificate details:"
CERT_SUBJECT=$(openssl x509 -in "$MACHINE_CERT" -noout -subject | sed 's/subject=//')
CERT_ISSUER=$(openssl x509 -in "$MACHINE_CERT" -noout -issuer | sed 's/issuer=//')
CERT_EXPIRES=$(openssl x509 -in "$MACHINE_CERT" -noout -enddate | sed 's/notAfter=//')
log "  Subject: $CERT_SUBJECT"
log "  Issuer: $CERT_ISSUER"
log "  Expires: $CERT_EXPIRES"

# Check for SAN
if openssl x509 -in "$MACHINE_CERT" -noout -text | grep -q "Subject Alternative Name"; then
  CERT_SAN=$(openssl x509 -in "$MACHINE_CERT" -noout -text | grep -A 1 "Subject Alternative Name" | tail -1 | tr -d ' ')
  log "  SAN: $CERT_SAN"
else
  log_warn "  No Subject Alternative Name found in certificate"
fi

# ============================================
# [4/9] Extract CA Certificate Chain
# ============================================

log_section "[4/9] Extracting CA Certificate Chain"

if [ ! -f "$CA_CERT" ] || [ ! -s "$CA_CERT" ]; then
  log "Downloading CA certificate..."
  
  curl -k -s "${SCEP_URL}?operation=GetCACert&message=0" -o /tmp/ndes-ca.p7b
  
  if [ ! -s /tmp/ndes-ca.p7b ]; then
    log_error "Failed to download CA certificate"
    exit 1
  fi
  
  openssl pkcs7 -in /tmp/ndes-ca.p7b -inform DER -print_certs -out "$CA_CERT"
  
  if [ ! -s "$CA_CERT" ]; then
    log_error "Failed to extract CA certificates"
    exit 1
  fi
  
  chmod 644 "$CA_CERT"
  log_success "CA certificate saved"
  
  # Show CA chain info
  log "CA Chain:"
  openssl storeutl -noout -text -certs "$CA_CERT" 2>/dev/null | grep "subject=" | sed 's/^/  /' >> "$LOG_FILE" || \
    grep "subject=" "$CA_CERT" | sed 's/^/  /' >> "$LOG_FILE"
else
  log "CA certificate already exists"
fi

# ============================================
# [5/9] Deprioritize Old Indra WiFi Profiles
# ============================================

log_section "[5/9] Deprioritizing Old Indra WiFi Profiles"

# Find all WiFi connections with "indra" in name (case-insensitive)
# EXCEPT our new managed profile (IndraNavia)
# Instead of deleting, set to LOWEST priority (backup)

ALL_WIFI_CONNECTIONS=$(nmcli -t -f NAME,TYPE connection show 2>/dev/null | grep ":wifi$" | cut -d: -f1 || true)

if [ -n "$ALL_WIFI_CONNECTIONS" ]; then
  log "Scanning for old Indra WiFi profiles..."
  
  DEPRIORITIZED_COUNT=0
  
  while IFS= read -r WIFI_NAME; do
    # Skip empty lines
    [ -z "$WIFI_NAME" ] && continue
    
    # Convert to lowercase for case-insensitive comparison
    WIFI_NAME_LOWER=$(echo "$WIFI_NAME" | tr '[:upper:]' '[:lower:]')
    
    # Check if contains "indra"
    if [[ "$WIFI_NAME_LOWER" == *"indra"* ]]; then
      
      # Skip if it's our NEW managed profile
      if [[ "$WIFI_NAME" == "$WIFI_CONNECTION_NAME" ]]; then
        log "  Skipping: $WIFI_NAME (our new profile)"
        continue
      fi
      
      # Deprioritize old Indra profile (keep as backup)
      log "  Deprioritizing: $WIFI_NAME (priority: $OLD_INDRA_PRIORITY - backup)"
      
      if nmcli connection modify "$WIFI_NAME" \
           connection.autoconnect-priority $OLD_INDRA_PRIORITY \
           connection.autoconnect yes 2>/dev/null; then
        DEPRIORITIZED_COUNT=$((DEPRIORITIZED_COUNT + 1))
      else
        log_warn "  Failed to modify: $WIFI_NAME"
      fi
    fi
  done <<< "$ALL_WIFI_CONNECTIONS"
  
  if [ $DEPRIORITIZED_COUNT -eq 0 ]; then
    log_success "No old Indra WiFi profiles found"
  else
    log_success "Deprioritized $DEPRIORITIZED_COUNT old Indra WiFi profile(s) to priority $OLD_INDRA_PRIORITY (kept as backup)"
  fi
else
  log "No WiFi connections found"
fi

log ""
log "WiFi Profile Strategy:"
log "  ✓ New IndraNavia: Priority $WIFI_PRIORITY (primary)"
log "  ✓ Old Indra profiles: Priority $OLD_INDRA_PRIORITY (backup)"
log "  ✓ Other WiFi: Priority $EXISTING_FALLBACK_PRIORITY (preserved)"
log "  ✓ NetworkManager auto-selects highest priority available"

# ============================================
# [6/9] Preserve Existing Connections as Fallback
# ============================================

log_section "[6/9] Preserving Existing Connections as Fallback"

# Preserve active wired connection (if not our managed one)
if [ -n "$ACTIVE_WIRED_CONNECTION" ] && [[ "$ACTIVE_WIRED_CONNECTION" != "$WIRED_CONNECTION_NAME" ]]; then
  log "Preserving existing wired connection: $ACTIVE_WIRED_CONNECTION"
  
  nmcli connection modify "$ACTIVE_WIRED_CONNECTION" \
    connection.autoconnect-priority $EXISTING_FALLBACK_PRIORITY \
    connection.autoconnect true 2>/dev/null || true
  
  log_success "Wired fallback configured (priority: $EXISTING_FALLBACK_PRIORITY)"
fi

# Preserve active WiFi connection (if not our managed one)
if [ -n "$ACTIVE_WIFI_CONNECTION" ] && [[ "$ACTIVE_WIFI_CONNECTION" != "$WIFI_CONNECTION_NAME" ]]; then
  
  log "Preserving existing WiFi connection: $ACTIVE_WIFI_CONNECTION"
  
  nmcli connection modify "$ACTIVE_WIFI_CONNECTION" \
    connection.autoconnect-priority $EXISTING_FALLBACK_PRIORITY \
    connection.autoconnect yes 2>/dev/null || true
  
  log_success "WiFi fallback configured (priority: $EXISTING_FALLBACK_PRIORITY)"
fi

# ============================================
# [7/9] Configure Wired 802.1x (Priority 100) - SAFE MODE
# ============================================

log_section "[7/9] Configuring Wired 802.1x (Priority 100) - SAFE MODE"

# Auto-detect wired interfaces
WIRED_INTERFACES=$(nmcli -t -f DEVICE,TYPE device 2>/dev/null | grep ethernet | cut -d: -f1 || true)

if [ -z "$WIRED_INTERFACES" ]; then
  log "INFO: No wired Ethernet interfaces found (WiFi-only machine)"
else
  log "Found wired interfaces: $(echo $WIRED_INTERFACES | tr '\n' ' ')"
  
  WIRED_INTERFACE=$(echo "$WIRED_INTERFACES" | head -1)
  log "Using wired interface: $WIRED_INTERFACE"
  
  # SAFE MODE: Check if interface is currently active
  SKIP_WIRED_ACTIVATION=false
  
  if [ -n "$ACTIVE_WIRED_CONNECTION" ] && [[ "$ACTIVE_WIRED_CONNECTION" != "$WIRED_CONNECTION_NAME" ]]; then
    log_warn "Interface $WIRED_INTERFACE currently active with: $ACTIVE_WIRED_CONNECTION"
    log_warn "SAFE MODE: Will NOT activate Wired-802.1x to avoid disruption"
    log "Profile will auto-activate when connected to 802.1x network"
    SKIP_WIRED_ACTIVATION=true
  fi
  
  # Check if profile exists and is correct (idempotent)
  if nmcli connection show "$WIRED_CONNECTION_NAME" &>/dev/null; then
    CURRENT_CERT=$(nmcli -t -f 802-1x.client-cert con show "$WIRED_CONNECTION_NAME" 2>/dev/null | cut -d: -f2- || true)
    
    if [[ "$CURRENT_CERT" == "file://$MACHINE_CERT" ]]; then
      log "IDEMPOTENT: Wired 802.1x already configured correctly"
    else
      log "Wired exists but uses old certificate, recreating..."
      nmcli connection delete "$WIRED_CONNECTION_NAME" >> "$LOG_FILE" 2>&1 || true
    fi
  fi
  
  # Create if needed
  if ! nmcli connection show "$WIRED_CONNECTION_NAME" &>/dev/null; then
    log "Creating wired 802.1x profile..."
    
    nmcli connection add \
      type ethernet \
      con-name "$WIRED_CONNECTION_NAME" \
      ifname "$WIRED_INTERFACE" \
      autoconnect yes \
      connection.autoconnect-priority $WIRED_PRIORITY \
      802-1x.eap "$EAP_METHOD" \
      802-1x.identity "host/$FQDN" \
      802-1x.client-cert "file://$MACHINE_CERT" \
      802-1x.private-key "file://$MACHINE_KEY" \
      802-1x.ca-cert "file://$CA_CERT" \
      ipv4.method auto \
      ipv6.method auto >> "$LOG_FILE" 2>&1
    
    record_state "CONNECTION_CREATED:$WIRED_CONNECTION_NAME"
    
    log_success "Wired 802.1x configured (priority: $WIRED_PRIORITY)"
  fi
  
  # SAFE MODE: Only activate if no existing connection is active
  if [ "$SKIP_WIRED_ACTIVATION" = true ]; then
    log_success "Wired-802.1x profile ready (will auto-activate on corporate network)"
  else
    if nmcli connection up "$WIRED_CONNECTION_NAME" >> "$LOG_FILE" 2>&1; then
      log_success "Wired activated (802.1x network detected)"
    else
      log_success "Wired-802.1x profile ready (will activate when connected to 802.1x switch)"
    fi
  fi
fi

# ============================================
# [7A/9] Ensure Ethernet Interface is Managed
# ============================================

log_section "[7A/9] Ensuring Ethernet Interfaces are Managed by NetworkManager"

# ============================================
# FIX: Disable interfaces in /etc/network/interfaces (Debian/Ubuntu only)
# ============================================

if [[ "$OS" == "debian" || "$OS" == "ubuntu" ]] && [ -f /etc/network/interfaces ]; then
  log "Detected Debian/Ubuntu - checking /etc/network/interfaces..."
  
  # Check if any ethernet interface is configured
  if grep -qE "^[[:space:]]*(auto|allow-hotplug)[[:space:]]+e(ns|th|np)[0-9]" /etc/network/interfaces || \
     grep -qE "^[[:space:]]*iface[[:space:]]+e(ns|th|np)[0-9]" /etc/network/interfaces; then
    
    log_warn "Ethernet interfaces found in /etc/network/interfaces"
    log_warn "This prevents NetworkManager from managing them"
    
    # Backup
    BACKUP_FILE="/etc/network/interfaces.backup-$(date +%Y%m%d-%H%M%S)"
    cp /etc/network/interfaces "$BACKUP_FILE"
    cp /etc/network/interfaces /etc/network/interfaces.backup-rollback
    record_state "FILE_MODIFIED:/etc/network/interfaces"
    
    log "Backed up to: $BACKUP_FILE"
    
    # Comment out ALL ethernet interface lines and related config
    sed -i \
      -e '/^[[:space:]]*auto[[:space:]]\+e\(ns\|th\|np\)[0-9]/,/^[[:space:]]*$/s/^/# DISABLED_BY_ENTERPRISE_SCRIPT: /' \
      -e '/^[[:space:]]*allow-hotplug[[:space:]]\+e\(ns\|th\|np\)[0-9]/,/^[[:space:]]*$/s/^/# DISABLED_BY_ENTERPRISE_SCRIPT: /' \
      -e '/^[[:space:]]*iface[[:space:]]\+e\(ns\|th\|np\)[0-9]/,/^[[:space:]]*$/s/^/# DISABLED_BY_ENTERPRISE_SCRIPT: /' \
      /etc/network/interfaces
    
    log_success "Disabled ethernet interfaces in /etc/network/interfaces"
    
    # Stop traditional networking service
    if systemctl is-active --quiet networking; then
      log "Stopping traditional networking service..."
      systemctl stop networking 2>/dev/null || true
      # Don't disable permanently - some systems need it for lo
    fi
    
    # Restart NetworkManager to take over
    log "Restarting NetworkManager to take control..."
    systemctl restart NetworkManager
    sleep 5
    
    log_success "NetworkManager restarted"
  else
    log "No ethernet interfaces in /etc/network/interfaces (OK)"
  fi
elif [[ "$OS" == "fedora" ]]; then
  log "Detected Fedora - no /etc/network/interfaces conflicts (OK)"
else
  log "No /etc/network/interfaces file found (OK)"
fi

# ============================================
# Ensure all ethernet interfaces are managed
# ============================================

if [ -n "$WIRED_INTERFACES" ]; then
  MANAGED_COUNT=0
  UNMANAGED_COUNT=0
  
  for WIRED_IF in $WIRED_INTERFACES; do
    # Check if interface is managed
    IF_STATE=$(nmcli -t -f DEVICE,STATE device status 2>/dev/null | grep "^${WIRED_IF}:" | cut -d: -f2 || echo "unknown")
    
    if [ "$IF_STATE" = "unmanaged" ] || [ "$IF_STATE" = "uhåndteret" ]; then
      log_warn "Interface $WIRED_IF is unmanaged - forcing NetworkManager management"
      UNMANAGED_COUNT=$((UNMANAGED_COUNT + 1))
      
      # Set to managed
      nmcli device set "$WIRED_IF" managed yes 2>/dev/null || true
      
      # Wait for NetworkManager to recognize
      sleep 3
      
      # Check if any connection is already bound to this interface
      EXISTING_CONN=$(nmcli -t -f NAME,DEVICE connection show 2>/dev/null | grep ":${WIRED_IF}$" | cut -d: -f1 | head -1 || true)
      
      if [ -z "$EXISTING_CONN" ]; then
        # No connection exists - check if default connection already created
        if nmcli connection show "Wired-Default-${WIRED_IF}" &>/dev/null; then
          log "Connection Wired-Default-${WIRED_IF} already exists (idempotent)"
        else
          # Create a default DHCP connection as fallback
          log "Creating default DHCP connection for $WIRED_IF (fallback, priority: $EXISTING_FALLBACK_PRIORITY)"
          
          nmcli connection add \
            type ethernet \
            con-name "Wired-Default-${WIRED_IF}" \
            ifname "$WIRED_IF" \
            autoconnect yes \
            connection.autoconnect-priority $EXISTING_FALLBACK_PRIORITY \
            ipv4.method auto \
            ipv6.method auto >> "$LOG_FILE" 2>&1
          
          if [ $? -eq 0 ]; then
            record_state "CONNECTION_CREATED:Wired-Default-${WIRED_IF}"
            log_success "Default wired connection created for $WIRED_IF"
          else
            log_warn "Failed to create default connection for $WIRED_IF"
          fi
        fi
      else
        log "Interface $WIRED_IF already has connection: $EXISTING_CONN (preserving)"
        
        # Ensure it has correct priority
        nmcli connection modify "$EXISTING_CONN" \
          connection.autoconnect-priority $EXISTING_FALLBACK_PRIORITY \
          connection.autoconnect yes 2>/dev/null || true
      fi
      
      # Verify it's now managed
      sleep 2
      NEW_STATE=$(nmcli -t -f DEVICE,STATE device status 2>/dev/null | grep "^${WIRED_IF}:" | cut -d: -f2 || echo "unknown")
      if [ "$NEW_STATE" != "unmanaged" ] && [ "$NEW_STATE" != "uhåndteret" ]; then
        log_success "Interface $WIRED_IF is now managed (state: $NEW_STATE)"
        MANAGED_COUNT=$((MANAGED_COUNT + 1))
      else
        log_warn "Interface $WIRED_IF still unmanaged after fix attempt"
        log_warn "This may require a system reboot to fully resolve"
      fi
    else
      log "Interface $WIRED_IF already managed (state: $IF_STATE)"
      MANAGED_COUNT=$((MANAGED_COUNT + 1))
    fi
  done
  
  log ""
  log "Interface Management Summary:"
  log "  ✓ Managed interfaces: $MANAGED_COUNT"
  if [ $UNMANAGED_COUNT -gt 0 ]; then
    log "  ⚠ Fixed unmanaged interfaces: $UNMANAGED_COUNT"
  fi
else
  log "No wired interfaces found"
fi

log ""
log "Network Priority Behavior:"
log "  Priority 100: Wired-802.1x → Used on 802.1x networks (corporate)"
log "  Priority $EXISTING_FALLBACK_PRIORITY: Wired-Default → Used on non-802.1x networks (home, café, etc.)"
log "  NetworkManager will auto-switch based on what's available"

# ============================================
# [8/9] Configure WiFi Connections - SAFE MODE
# ============================================

log_section "[8/9] Configuring WiFi Connections - SAFE MODE"

# Auto-detect WiFi interfaces
WIFI_INTERFACES=$(nmcli -t -f DEVICE,TYPE device 2>/dev/null | grep wifi | cut -d: -f1 || true)

# Initialize SSID_HIDDEN for summary (default)
SSID_HIDDEN="N/A"

if [ -z "$WIFI_INTERFACES" ]; then
  log "INFO: No WiFi interfaces found (wired-only machine)"
  log "Skipping WiFi configuration"
else
  log "Found WiFi interfaces: $(echo $WIFI_INTERFACES | tr '\n' ' ')"
  
  WIFI_INTERFACE=$(echo "$WIFI_INTERFACES" | head -1)
  log "Using WiFi interface: $WIFI_INTERFACE"
  
  # Enable WiFi
  nmcli radio wifi on &>/dev/null
  sleep 2
  
  # SAFE MODE: Check if WiFi is currently active
  SKIP_WIFI_ACTIVATION=false
  
  if [ -n "$ACTIVE_WIFI_CONNECTION" ] && [[ "$ACTIVE_WIFI_CONNECTION" != "$WIFI_CONNECTION_NAME" ]]; then
    
    log_warn "WiFi currently active with: $ACTIVE_WIFI_CONNECTION"
    log_warn "SAFE MODE: Will NOT activate enterprise WiFi to avoid disruption"
    log "Profiles will auto-activate when on corporate network"
    SKIP_WIFI_ACTIVATION=true
  fi
  
  # Scan for available networks (needed for hidden SSID detection)
  log "Scanning for WiFi networks..."
  nmcli device wifi rescan ifname "$WIFI_INTERFACE" &>/dev/null || true
  sleep 3
  
  # -------------------------------------------
  # Configure IndraNavia (802.1x - guest VLAN fallback if no cert)
  # -------------------------------------------
  
  log ""
  log "Configuring IndraNavia (802.1x with guest VLAN fallback, priority $WIFI_PRIORITY)..."
  
  # Auto-detect if SSID is hidden or visible
  SSID_HIDDEN="yes"  # Default: assume hidden
  log "Detecting if $WIFI_SSID is broadcasting SSID..."
  
  if nmcli device wifi list ifname "$WIFI_INTERFACE" 2>/dev/null | grep -qw "$WIFI_SSID"; then
    SSID_HIDDEN="no"
    log_success "$WIFI_SSID is visible (broadcasting SSID)"
  else
    log "$WIFI_SSID not visible in scan (hidden or out of range)"
    log "Configuring for hidden SSID mode (active probe requests)"
  fi
  
  # Check if profile already exists and is correctly configured
  if nmcli connection show "$WIFI_CONNECTION_NAME" &>/dev/null; then
    CURRENT_CERT=$(nmcli -t -f 802-1x.client-cert con show "$WIFI_CONNECTION_NAME" 2>/dev/null | cut -d: -f2- || true)
    CURRENT_PRIORITY=$(nmcli -t -f connection.autoconnect-priority con show "$WIFI_CONNECTION_NAME" 2>/dev/null | cut -d: -f2 || true)
    CURRENT_SSID=$(nmcli -t -f 802-11-wireless.ssid con show "$WIFI_CONNECTION_NAME" 2>/dev/null | cut -d: -f2 || true)
    CURRENT_HIDDEN=$(nmcli -t -f 802-11-wireless.hidden con show "$WIFI_CONNECTION_NAME" 2>/dev/null | cut -d: -f2 || true)
    
    # Check if all settings match
    if [[ "$CURRENT_SSID" == "$WIFI_SSID" && \
          "$CURRENT_PRIORITY" == "$WIFI_PRIORITY" && \
          "$CURRENT_CERT" == "file://$MACHINE_CERT" && \
          "$CURRENT_HIDDEN" == "$SSID_HIDDEN" ]]; then
      log "IDEMPOTENT: IndraNavia 802.1x already configured correctly (hidden: $SSID_HIDDEN)"
    else
      log "IndraNavia exists but misconfigured, recreating..."
      log_debug "Current: cert=$CURRENT_CERT, hidden=$CURRENT_HIDDEN, priority=$CURRENT_PRIORITY"
      log_debug "Expected: cert=file://$MACHINE_CERT, hidden=$SSID_HIDDEN, priority=$WIFI_PRIORITY"
      nmcli connection delete "$WIFI_CONNECTION_NAME" >> "$LOG_FILE" 2>&1 || true
    fi
  fi
  
  if ! nmcli connection show "$WIFI_CONNECTION_NAME" &>/dev/null; then
    log "Creating IndraNavia 802.1x profile (hidden: $SSID_HIDDEN)..."
    
    nmcli connection add \
      type wifi \
      con-name "$WIFI_CONNECTION_NAME" \
      ifname "$WIFI_INTERFACE" \
      ssid "$WIFI_SSID" \
      autoconnect yes \
      connection.autoconnect-priority $WIFI_PRIORITY \
      connection.autoconnect-retries 3 \
      wifi.hidden "$SSID_HIDDEN" \
      wifi-sec.key-mgmt wpa-eap \
      802-1x.eap "$EAP_METHOD" \
      802-1x.identity "host/$FQDN" \
      802-1x.client-cert "file://$MACHINE_CERT" \
      802-1x.private-key "file://$MACHINE_KEY" \
      802-1x.ca-cert "file://$CA_CERT" \
      ipv4.method auto \
      ipv4.dhcp-timeout 20 \
      ipv6.method auto >> "$LOG_FILE" 2>&1
    
    record_state "CONNECTION_CREATED:$WIFI_CONNECTION_NAME"
    
    log_success "IndraNavia configured (802.1x, hidden: $SSID_HIDDEN, priority: $WIFI_PRIORITY)"
    
    if [ "$SSID_HIDDEN" = "yes" ]; then
      log "  Note: Using active SSID probing (hidden network mode)"
    else
      log "  Note: Using passive scanning (visible network mode)"
    fi
    log "  Note: Will use guest VLAN if certificate auth fails"
  fi
  
  # SAFE MODE: Only activate if not disrupting
  if [ "$SKIP_WIFI_ACTIVATION" = false ]; then
    if nmcli connection up "$WIFI_CONNECTION_NAME" >> "$LOG_FILE" 2>&1; then
      sleep 3
      IP=$(nmcli -t -f IP4.ADDRESS con show "$WIFI_CONNECTION_NAME" 2>/dev/null | head -n1 || true)
      log_success "IndraNavia connected with IP $IP"
    else
      log_success "IndraNavia profile ready (will connect when SSID is in range)"
    fi
  else
    log_success "IndraNavia profile ready (will auto-activate on corporate network)"
  fi
fi

# ============================================
# [9/9] Verification and Summary
# ============================================

log_section "[9/9] Deployment Summary"

# Run post-deployment verification
verify_deployment

log ""
log "Certificate Information:"
log "  Subject: $(openssl x509 -in $MACHINE_CERT -noout -subject | sed 's/subject=//')"
log "  Expires: $CERT_EXPIRES"
log "  Auto-renewal: ENABLED"
log "  Request ID: $REQUEST_ID"

log ""
log "Active Certificates (managed by certmonger):"
getcert list 2>/dev/null | grep "Request ID\|status:\|expires:" | sed 's/^/  /' >> "$LOG_FILE"

log ""
log "Network Connections (by priority):"
nmcli -t -f NAME,TYPE,AUTOCONNECT-PRIORITY,STATE connection show 2>/dev/null | \
  sort -t: -k3 -rn | \
  head -10 | \
  while IFS=: read -r name type priority state; do
    STATUS_ICON=""
    case "$state" in
      activated) STATUS_ICON="✓" ;;
      activating) STATUS_ICON="⟳" ;;
      *) STATUS_ICON="○" ;;
    esac
    log "  $STATUS_ICON [$priority] $name ($type): $state"
  done

log ""
log "Network Interfaces:"
nmcli device status >> "$LOG_FILE" 2>&1

log ""
log_section "Deployment Complete!"

log "Configuration Summary:"
log "  ✓ Wired 802.1x: Priority $WIRED_PRIORITY (highest)" 
log "  ✓ WiFi IndraNavia (802.1x, guest fallback): Priority $WIFI_PRIORITY"
if [ "$SSID_HIDDEN" != "N/A" ]; then
  log "  ✓ WiFi IndraNavia: Auto-detected SSID visibility (hidden: $SSID_HIDDEN)"
fi
log "  ✓ Other connections: Priority $EXISTING_FALLBACK_PRIORITY (preserved)"
log "  ✓ Certificate auto-renewal: ENABLED (certmonger)"
log "  ✓ Machine: NOT domain-joined (hostname-based certificate)"
log "  ✓ All ethernet interfaces: Managed by NetworkManager"

log ""
log "Certificate Management:"
log "  ✓ Only ONE active 802.1x certificate: $REQUEST_ID"
log "  ✓ Old duplicate certificates: CLEANED UP"
log "  ✓ Certmonger auto-renewal: ACTIVE (~30 days before expiry)"
log "  ✓ No manual intervention required"

log ""
log "OS-Specific Fixes Applied:"
if [[ "$OS" == "debian" || "$OS" == "ubuntu" ]]; then
  log "  ✓ Debian/Ubuntu: /etc/network/interfaces conflicts resolved"
  log "  ✓ Traditional networking disabled for ethernet"
elif [[ "$OS" == "fedora" ]]; then
  log "  ✓ Fedora: No conflicts (uses NetworkManager natively)"
fi

log ""
log "WiFi Profile Management:"
log "  ✓ Deprioritized: All old *indra* WiFi profiles (priority $OLD_INDRA_PRIORITY - backup)"
if [ "$SSID_HIDDEN" != "N/A" ]; then
  log "  ✓ Created: IndraNavia (802.1x with guest VLAN fallback, priority $WIFI_PRIORITY)"
  log "  ✓ SSID Detection: Automatic (hidden vs visible)"
else
  log "  ✓ WiFi: Not configured (wired-only machine)"
fi
log "  ✓ Kept: All non-Indra WiFi profiles (priority $EXISTING_FALLBACK_PRIORITY)"

log ""
log "SAFE MODE Behavior:"
log "  ✓ NO DISRUPTION: Existing connections preserved"
log "  ✓ AUTO-SWITCH: Profiles activate automatically on corporate network"
log "  ✓ FALLBACK: Current connection remains active until better option available"
log "  ✓ ETHERNET: Auto-managed, works everywhere (802.1x and non-802.1x)"
log "  ✓ ROLLBACK: Automatic rollback on critical failures"
log "  ✓ BACKUP: Old Indra WiFi profiles kept as emergency backup (priority $OLD_INDRA_PRIORITY)"

log ""
log "Network Priority (when on corporate network):"
log "  1. Wired connected → Wired 802.1x (priority $WIRED_PRIORITY)"
if [ "$SSID_HIDDEN" != "N/A" ]; then
  log "  2. Wired disconnected + IndraNavia → IndraNavia 802.1x (priority $WIFI_PRIORITY)"
fi
log "  3. Corporate unavailable → Existing connections (priority $EXISTING_FALLBACK_PRIORITY)"
log "  4. Emergency backup → Old Indra profiles (priority $OLD_INDRA_PRIORITY)"

log ""
log "Authentication Methods:"
log "  - Wired: 802.1x TLS (certificate)"
if [ "$SSID_HIDDEN" != "N/A" ]; then
  log "  - IndraNavia: 802.1x TLS (certificate, guest VLAN if auth fails)"
fi
log "  - Other WiFi: Preserved as-is"

log ""
log "Troubleshooting:"
log "  - Live logs: journalctl -u NetworkManager -f"
log "  - Connections: nmcli connection show"
log "  - Devices: nmcli device status"
log "  - Certificate: getcert list"
log "  - Full deployment log: cat $LOG_FILE"

log ""
log "IMPORTANT: If ethernet interface is still 'unmanaged', reboot is recommended."
log ""

# ============================================
# Final output to stdout for ManageEngine
# ============================================

echo "SUCCESS: Enterprise network deployment completed on $(hostname)"
echo "Certificate expires: $CERT_EXPIRES"
echo "Wired 802.1x: Configured (priority $WIRED_PRIORITY)"
if [ "$SSID_HIDDEN" != "N/A" ]; then
  echo "WiFi IndraNavia: Configured (priority $WIFI_PRIORITY, hidden: $SSID_HIDDEN)"
fi
echo "Old Indra WiFi: Deprioritized to priority $OLD_INDRA_PRIORITY (backup)"
echo "Full log: $LOG_FILE"

exit 0
